# .agentrules - AI Behavior Rules for AIPM

**CRITICAL**: This file defines how AI assistants must work with AIPM. Read this ENTIRE file completely before starting ANY work.

## 🛑 MANDATORY STARTUP SEQUENCE - DO NOT SKIP

### 1. Read Everything First
**BEFORE ANY ACTION**, you MUST:
1. Read this ENTIRE .agentrules file completely
2. Run `ls -la` to understand the workspace structure
3. Read AIPM.md in its entirety
4. Read current-focus.md completely
5. Read changelog.md to understand previous session state

**NO EXCEPTIONS**: Do not create files, run commands, or make changes until you've completed this sequence.

### 2. Critical Guardrails
- **NEVER touch memory files directly** - Only use scripts to control them
- **NEVER use git commands directly** - ALWAYS use wrapper scripts (save.sh, revert.sh, start.sh, stop.sh)
- **NEVER create parallel paths** - Always understand existing structure first
- **ALWAYS verify before acting** - Use `ls -la`, read files, understand context

### 3. Consistency is Mandatory
- **Read key learnings** from existing files
- **Follow established patterns** exactly
- **Use existing utilities** - don't recreate what exists
- **Respect the architecture** - it exists for good reasons

## 🚦 Core Understanding: AIPM Solves Organizational Amnesia

AIPM brings git-powered decision tracking to ALL teams - not just developers. It creates isolated workspaces where:
- Every decision is tracked with full context
- AI assistants maintain persistent memory per workspace
- Teams work in parallel without conflicts
- Knowledge transfers seamlessly between sessions

**Key Innovation**: Each workspace has `.aipm/opinions.yaml` that defines how that specific team works.

---

## ⚠️ CRITICAL IMPLEMENTATION DIRECTIVES

### 🔴 CRITICAL FILE REVERSION BUG WARNING
**KNOWN ISSUE**: Some AI coding environments have a bug where files can spontaneously revert to previous states during a session. This can cause implemented code to be lost!

**GUARDRAILS TO PREVENT DATA LOSS**:
1. **COMMIT FREQUENTLY**: After implementing each script/module, commit immediately
2. **VERIFY CHANGES**: Always grep/check that your edits actually persisted
3. **WATCH FOR SYSTEM REMINDERS**: Messages like "file was modified by user or linter" indicate potential reversions
4. **RE-CHECK BEFORE COMMITTING**: Run `git diff` to ensure all expected changes are present
5. **DOCUMENT MISSING IMPLEMENTATIONS**: If code is lost, document what was implemented

**RECOVERY PROTOCOL**:
- If you notice missing implementations after a commit, re-implement immediately
- Check all files in the commit, not just the one you're working on
- Document the issue in changelog.md for awareness

### 📋 Module Implementation Rules

#### When implementing wrapper scripts (start.sh, stop.sh, save.sh, revert.sh):
**MANDATORY**: Read `.aipm/scripts/test/workflow.md` FIRST - it is the single source of truth
- **NO DIRECT OUTPUT**: Never use echo/printf - ONLY shell-formatting.sh functions
- **NO DIRECT GIT**: Never use git commands - ONLY version-control.sh functions
- **NO DIRECT MEMORY OPS**: Never manipulate memory files - ONLY migrate-memories.sh functions
- **FOLLOW GUARDRAILS**: Workflow.md has exact line references and patterns
- **TEST INCREMENTALLY**: Implement section by section, test before proceeding

#### When working on core modules:
- **shell-formatting.sh**: ALL output goes through these functions
- **version-control.sh**: ALL git operations go through these functions
- **migrate-memories.sh**: ALL memory operations go through these functions
- **opinions-loader.sh**: THE CORNERSTONE - loads workspace-specific configuration
- Modularity is MANDATORY - each function must be independently testable
- 100% test coverage achieved on version-control.sh - maintain this standard

### ✅ Manual Review Directive
**CRITICAL**: NO change is considered complete until manually reviewed by the user
- After implementing any change, WAIT for explicit user confirmation
- Document what was changed clearly
- The user will test and verify before moving to the next task
- This prevents cascading errors and ensures quality

---

## 🎯 Workspace Context Management

### Understanding Workspaces
Every workspace (framework or project) has its own:
- `.aipm/opinions.yaml` - Defines branching rules, memory categories, lifecycle policies
- `.aipm/memory/` - Isolated AI memory that persists between sessions
- Branch namespace - e.g., `AIPM_*` for framework, `MKT_*` for marketing

### Determining Your Context
Before ANY work, determine which workspace you're in:

1. **Framework Workspace**: Improving AIPM itself
   - Working on AIPM core functionality
   - Updating framework documentation
   - Branches use `AIPM_` prefix

2. **Project Workspace**: Using AIPM for a specific project
   - Working on project-specific tasks
   - Project files in symlinked directory
   - Branches use project-specific prefix

**NEVER mix contexts. Each workspace is completely isolated.**

---

## 📂 Updated Directory Structure

```
AIPM/                              # Framework workspace
├── .aipm/                         # THE AIPM HUB - Everything lives here
│   ├── opinions.yaml             # Framework workspace configuration
│   ├── memory.json               # Symlink to MCP memory (AI-agnostic)
│   ├── memory/                   # Persistent memory storage
│   │   ├── local_memory.json     # Framework memory (git-tracked)
│   │   └── backup.json           # Session backup (gitignored)
│   ├── scripts/                  # All AIPM scripts
│   │   ├── modules/              # Core modules
│   │   └── test/                 # Test files and docs
│   ├── docs/                     # Technical documentation
│   └── templates/                # Project templates
│
├── start.sh → .aipm/scripts/start.sh    # Convenience symlinks
├── stop.sh → .aipm/scripts/stop.sh
├── save.sh → .aipm/scripts/save.sh
├── revert.sh → .aipm/scripts/revert.sh
│
├── .agentrules                   # This file - AI behavior rules
├── AIPM.md                       # Framework architecture
├── README.md                     # High-level overview
├── current-focus.md              # Active tasks
├── broad-focus.md                # Future vision
├── changelog.md                  # Change history
│
└── YourProject/                  # Symlink to actual project
    └── .aipm/                    # Project's AIPM configuration
        ├── opinions.yaml         # Project-specific rules
        └── memory/               # Project-specific memory
```

---

## 🔄 MANDATORY: Use Wrapper Scripts ONLY

### Git Operations - NEVER Direct Commands
**WRONG**: `git add .`, `git commit`, `git push`, `git checkout`  
**RIGHT**: Use the wrapper scripts below

### The Only Git Interface You Should Use:

#### save.sh - For ALL Git Operations
```bash
# This is your ONLY interface to git
./save.sh "Clear description of changes"

# What it does for you:
# - Stages all changes (git add -A)
# - Commits with your message
# - Includes memory statistics
# - Maintains audit trail
```

#### revert.sh - For Time Travel
```bash
# Browse and restore previous states
./revert.sh

# What it does for you:
# - Interactive commit selection
# - Safe memory restoration
# - Backup before reverting
```

#### start.sh / stop.sh - Session Management
```bash
# Start work
./start.sh                        # Interactive mode
./start.sh --framework            # Framework work
./start.sh --project ProjectName  # Project work

# End work (MUST match how you started)
./stop.sh
./stop.sh --framework
./stop.sh --project ProjectName
```

### Why This Matters
1. **Memory Safety**: Scripts handle memory backup/restore
2. **Branch Management**: Scripts respect workspace opinions
3. **Audit Trail**: Scripts maintain proper history
4. **Consistency**: Scripts enforce standards

**VIOLATION EXAMPLE**: If user says "commit the changes", you should:
- ❌ NOT run: `git add . && git commit -m "message"`
- ✅ DO run: `./save.sh "message"`

**EXCEPTION**: Only use direct git commands if user EXPLICITLY says:
- "Run git status for me"
- "Show me git log directly"
- "I want you to use git diff"

---

## 📚 Documentation Rules

### Read These First (In Order)
1. **README.md** - Understand the problem AIPM solves
2. **AIPM.md** - Understand the architecture
3. **current-focus.md** - Know what's being worked on
4. **.aipm/opinions.yaml** - Understand workspace configuration

### Documentation Updates
- **Framework changes** → Update framework docs only
- **Project work** → Update project docs only
- **Each workspace maintains**:
  - current-focus.md (active tasks)
  - broad-focus.md (vision)
  - changelog.md (history)
  - .agentrules (if needed)

### Use Sequential Thinking
For complex understanding tasks:
```
Use mcp__sequential-thinking__sequentialthinking to analyze AIPM.md
This provides complete framework architecture understanding
```

---

## 🚫 Common Mistakes to Avoid

1. **Mixing Workspaces**: Each workspace is isolated - don't cross boundaries
2. **Direct Operations**: Always use the module functions, never direct commands
3. **Forgetting Context**: Always know which workspace you're in
4. **Skipping Opinions**: Always check opinions.yaml for workspace rules
5. **Manual Memory Edits**: Never edit memory files directly - use migrate-memories.sh

---

## 🆘 Quick Reference

| Question | Answer |
|----------|--------|
| What is AIPM? | Read README.md - Git for every team's decisions |
| How does it work? | Read AIPM.md - Architecture and modules |
| What needs doing? | Read current-focus.md for active tasks |
| What's the vision? | Read broad-focus.md for future plans |
| How is workspace configured? | Check .aipm/opinions.yaml |
| What are the rules? | You're reading them! |

---

## 🎭 Role Clarity

When working with AIPM, you are either:
1. **Framework Developer**: Improving AIPM's capabilities
   - Updating core modules
   - Enhancing documentation
   - Adding new features

2. **Workspace User**: Using AIPM for specific work
   - Following workspace opinions
   - Tracking decisions
   - Maintaining project memory

**Always be clear about your role and workspace.**

---

## 📖 Documentation Maintenance Rules

### CRITICAL: Never Use Line Numbers in Documentation
Line numbers in documentation are fragile and break with ANY code change. They create a maintenance nightmare and make documentation quickly outdated.

**❌ NEVER DO THIS**:
```markdown
# Bad Examples - These break with any code change!

"The initialization happens at line 237 in start.sh"
"See lines 450-523 for the implementation"
"The bug is on line 89"
"Check wrapper scripts starting at line 172"
"From opinions-state.sh (lines 2417-2545):"
"Memory sync logic (lines 237-260)"
```

**✅ ALWAYS DO THIS**:
```markdown
# Good Examples - These survive code changes!

"The initialization happens in the initialize_state() function"
"See the 'State Initialization' section"
"The bug is in the validate_branch_name() function"
"Check the wrapper scripts module"
"From opinions-state.sh in the initialize_state() function:"
"Memory sync logic in the sync_remote_memory() function"
```

### Better Reference Approaches
1. **Function Names**: `"See the get_value() function in opinions-state.sh"`
2. **Section Names**: `"Documented in the 'Memory Flow' section"`
3. **YAML Paths**: `"Defined at workflows.branchCreation.startBehavior in opinions.yaml"`
4. **Search Hints**: `"Search for 'compute_all_branch_patterns' to find the implementation"`
5. **Module Names**: `"Implemented in the version-control.sh module"`

### Why This Matters
- Code changes frequently during development
- Line numbers become invalid after ANY edit
- Broken references confuse users and AI assistants
- Maintenance becomes impossible as references drift
- Documentation should be resilient to refactoring

---

## 🔐 Security and Safety Rules

### Memory Files are SACRED - Never Touch Directly
1. **NEVER edit .aipm/memory/local_memory.json directly**
2. **NEVER modify .aipm/memory.json** - It's a symlink to global memory
3. **NEVER create memory files manually**
4. **ONLY scripts can touch memory files** - They handle atomicity and safety

### Why Memory Files are Protected
- **Atomicity**: Scripts ensure operations complete or rollback
- **Validation**: Scripts verify JSON structure and prefixes
- **Backup**: Scripts maintain safety backups
- **Coordination**: Scripts handle MCP server timing

### Other Safety Rules
1. **Always backup before major operations** - Use migrate-memories.sh functions
2. **Respect branch protection** - Check opinions.yaml for protected branches
3. **Validate memory operations** - Ensure proper entity prefixes
4. **Keep secrets out** - No passwords, tokens, or keys in memory

---

*Remember: AIPM brings git's superpowers to every team. These rules ensure it works reliably and safely.*